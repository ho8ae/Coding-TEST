## 파이썬 문자열 메서드 정리

🔥 참고: 파이썬 문자열에도 다양한 도움이 되는 메서드들이 많습니다. 배열(리스트) + for문으로도 충분히 해결할 수 있으니 너무 강박하지 마세요.
정규표현식 - import re 모듈 사용
🔥 특정문자 제거: re.sub(r'[^abc]', '', s)

정규식 패턴은 r''로 표현
a, b, c 셋 중에 하나가 아니라면 제거됨
[]: ~ 중의 하나
[xy]: x 와 y 중에 하나를 의미


🔥 문자열 삭제 메서드

문자열 치환: original_string.replace("삭제할 부분", "")
여러 패턴 치환: re.sub(r'패턴', '', string)


🔥 문자열 분할:

string.split("구분자") - 구분자로 분할하여 리스트 반환
string.partition("구분자") - (앞부분, 구분자, 뒷부분) 튜플 반환


🔥 split() 사용 시 정규표현식:

점(.)을 구분자로 사용할 경우: re.split(r'\.', string)
정규표현식 사용: re.split(r'[,.;]', string) - 쉼표, 점, 세미콜론으로 분할


🔥 연속된 문자 제거:

"1002".split("0") → ['1', '', '2']
빈 문자열도 포함됨


🔥 토큰 개수: len(string.split())
🔥 char를 문자열로: 파이썬에서는 단일 문자도 문자열임
문자 관련 함수:

str.isdigit() - 숫자인지
str.isalpha() - 알파벳인지
str.isupper() - 대문자인지
str.upper() - 대문자로 변환
str.lower() - 소문자로 변환


아스키코드 변환:

문자 → 코드: ord('A')
코드 → 문자: chr(65)


부분 문자열: string[start:end] (슬라이싱)
🔥 문자열 뒤집기: string[::-1]
문자열 연결:

''.join(문자열_리스트) - 구분자 없이 연결
' '.join(문자열_리스트) - 공백으로 구분하여 연결


🔥 문자열 비교:

<, >, == 연산자로 사전식 비교 가능
정밀한 비교는 string1 < string2


🔥 문자열 탐색:

str2 in str1 - 포함 여부 (True/False)
str1.find(str2) - 위치 반환 (없으면 -1)
str1.index(str2) - 위치 반환 (없으면 예외 발생)


🔥 문자열 특정 위치 문자 바꾸기:

파이썬 문자열은 불변(immutable)이므로 직접 수정 불가
리스트로 변환 후 수정:
```
pythonCopys_list = list(my_string)
s_list[7] = 'X'
new_string = ''.join(s_list)
```


🆘 문자열 비교는 == 연산자 사용 (Java의 equals와 동일)

문자열 객체 비교(메모리 위치): is 연산자 사용

___


## 자료구조

자료구조 선택: 큐, 덱, 스택 쓰기 전에 중간 요소 필요없는지 점검하자.
🔥 중간 요소 접근 -> 인덱스 알면 append, pop으로 해결 가능
🔥 자료구조 원소 읽을 때 주의: get, peek, pop 등 할 때, 원소가 하나라도 있는지 None이 아닌지 민감하게 반응하자!!!
in 연산자 주의: list_of_tuples = [] 에서 검색 시 선형 시간 소요
집합(set) 값 읽기: list_values = list(set_values)
넓이: 좌표평면 상의 넓이를 구하기 위해 2차원 리스트로 표현하여 구할 수 있다.
원소 제거:
🔥 my_list.remove(1): 첫번째로 등장하는 1을 제거
🔥 여러 원소 제거: my_list = [x for x in my_list if x != 1]
🔥 fruits.remove("apple")
리스트 삽입 순서 지정 가능: list.insert(i, 원소) (i: 추가하고 싶은 index)
값 삽입, 수정, 삭제 재빠르게 해야 한다면: 딕셔너리(dict) 이용!!!
🔥 연결성: 정렬, 삽입, 삭제 등 하면 다른 곳에서도 바뀐다는 걸 인지하자!!
2차원 배열 복사 주의: clone = map_array.copy() 이걸로 안 된다!! (얕은 복사)
딕셔너리 순회:
pythonCopyfor key, value in my_dict.items():
    print(key, value)

🔥 for key in my_dict.keys():
    print(key)
    
🔥 for value in my_dict.values():
    print(value)
우선순위 큐:
pythonCopyimport heapq

pq = []  # 최소 힙 (우선순위가 낮은 숫자 순)
🔥 # 최대 힙 구현 (부호를 바꿔서 저장하고 꺼낼 때 다시 바꿈)
heapq.heappush(pq, -item)  # 삽입
item = -heapq.heappop(pq)  # 추출
깊은 복사:
pythonCopyimport copy

# 리스트 깊은 복사
arr_copy = arr.copy()  # 얕은 복사
🔥 deep_copy_list = copy.deepcopy(original_list)  # 깊은 복사
스택, 큐:
🔥 in 연산자: 특정 요소가 있는지 확인 (예: if item in my_stack:)
🔥 스택 위치 찾기: my_stack.index(item) (없으면 ValueError)
🔥 덱:
pythonCopyfrom collections import deque
d = deque()

d.appendleft()  # 앞에 추가
d.append()      # 뒤에 추가
d.popleft()     # 앞에서 제거하고 반환
d.pop()         # 뒤에서 제거하고 반환
d[0]            # 앞에서 첫 원소 확인
d[-1]           # 뒤에서 첫 원소 확인
🔥🔥 큐, 스택 순회 - for문으로 가능!
🆘 큐에서 중간 요소 삭제하고 싶다면 remove 메서드
🆘 자료구조 remove 메서드 구분!!

리스트, 덱: remove(value) - 값으로 삭제
리스트 인덱스로 삭제: del my_list[index] 또는 my_list.pop(index)

🆘 힙, 큐, 스택 size를 기준으로 무언가를 할 때 조심해!!!!
pythonCopy# 오류 가능성 - 크기가 변함
for i in range(len(pq)-1):
    # 종료조건 실시간으로 변한다!

# 대신 while을 이용하자
while len(pq) > 1:
    # 안전하게 처리
🆘 딕셔너리 정렬된 리스트 얻기:
pythonCopy# value를 기준으로 정렬
sorted_items = sorted(my_dict.items(), key=lambda x: x[1], reverse=True)

# key를 기준으로 value 순서로 정렬
sorted_keys = sorted(my_dict.keys(), key=lambda x: my_dict[x], reverse=True)
🆘 덱을 통해서 마치 '원'형의 자료구조를 구현할 수 있음
🆘 덱에서 중간 요소에 접근해야 한다면 popleft, append로 구현할 수 있음!!
🆘 덱에서 삭제하고 싶은 idx가 있다면, idx만큼 d.append(d.popleft())하면 됨. 그리고 popleft하면 삭제!
백트랙킹, DFS, BFS
🔥 본질: 순서, 문어발(위아래)
🔥 유형: 순열(visited), 조합(i+1), 같순열(개수 카운트), 채워넣기(i-문어발을 생각해!, continue)(순서x)(중복조합과 유사)
🔥 사고: 어떤 예상값이 나와야 하는지부터 파악해보기
🔥 복구: for문 뿐만 아니라 if문에서 한 것까지 복원해야 한다!
🔥 특히 배열, 리스트라면 더 주의해서!!!
깔끔하게 복구되었는지 민감하게 거시적으로 확인하자.
🔥 실수 주의: 조합에서는 for문 안에 일반적으로 i만 나온다! idx 아니라!!
본질: for문 안에 dfs 생각해봐. 모든 경우의 수 돌기 위함. 이걸 풀어헤치면 dfs가 여러 줄 나올 수 있음!! 반복문에 얽매이지 말고, 어떤 결과를 구해야하는 지부터 파악하고, 그에 따라 코드 짜자.
🔥 그래프 주의: 1번 부터 시작하면 n+1, i <= n이다!!!!
🔥 인접 행렬 혹은 인접 리스트에 정보 저장할 때, 양방향 그래프라면 양쪽에 추가해야 된다!! 하나만 추가하지마!!
그리고 간선의 삭제, 복구도 양쪽에 해야한다!
'최단 경로'로 이동했을 때!!!!!! '거리' 관련은!!!!!!! '가깝고' '멀고' 관련은!!! -> BFS!!!!
🔥 bfs 방문처리는 while 문 안에서
🔥 dfs 방문처리는 dfs 첫 줄에서
🔥 백트랙킹, dfs, bfs 등을 여러 번 시행해야 하는 문제라면, visited와 같이 하나의 시행에서 사용된 것들 초기화하는 거 잊지 말자!!!!
🆘 전역 변수로 visited 사용 시 주의:
```
pythonCopyvisited = None

def initialize():
    global visited
    visited = [[False] * m for _ in range(n)]
```
할당하는 거 잊지 말자!! 이런 거 때문에 None 에러 날 수도 있음.
🆘 특정 행동을 계속 반복해야 한다면 -> 재귀 -> 백트랙킹, dfs, bfs
🆘 그런데 좀 더 정형화된 행동을 반복하고, 시간 복잡도가 타이트하다면 dp(순차적 사고 특히 중요!)!!
🆘 그래프 탐색의 핵심 원리 - 반복, 노드, visited(종료)
🆘 결과적 사고보다는 순차적 사고로 먼저 ㄱㄱ. 하나의 시행 단위를 인식하기.
🆘 배열 다른 함수로 넘겨서 처리할 때 조심. 원하지 않은 변경이 일어날 수 있다!!
🆘 하나의 시행단위를 정확히 인식하기.
🆘🆘 전형적이지 않은 상황에서 떠올린 알고리즘이 있을 때, 해당 알고리즘이 적용되는지 엄밀히 검증하기.
🆘 '백트랙킹에서의 본질 - 순서, 위아래' 순서가 필요한지 점검하기.
백트랙킹에서 visited 복원을 하지 않는다는 건 순서가 필요 없다는 것!!
🆘 왠만하면 그래프 관련해서는 visited = [False] * n 보다 graph = [0] * n 쓰는 게 좋음. 담을 수 있는 정보가 훨씬 고차원적임.
정렬
배열 내림차순: sorted(arr, reverse=True)
🔥 부분 정렬: sorted(arr[from_idx:to_idx])
🔥 정렬 기준 지정 가능:
pythonCopy# 람다 함수로 정렬 기준 지정
sorted(my_list, key=lambda e: e.y)
# 또는 
my_list.sort(key=lambda e: e.y)
이진탐색
🔥 10억과 같이 탐색 범위가 굉장히 크다면, 이진 탐색 떠올려라!!
```
def binary_search(arr, target, start, end):
    while start <= end:
        mid = (start + end) // 2
        
        if arr[mid] == target:
            return mid
            
        if arr[mid] > target:
            end = mid - 1
        else:
            start = mid + 1
    return -1
```
🔥 내장 이진 탐색:
```
pythonCopyimport bisect
idx = bisect.bisect_left(arr, target)  # 정렬된 위치 찾기
```
기타
🔥 배열끼리 중복 검사하고 싶을 때, copy, sort, join하면 될 듯.
정렬해서 출력하거나 처리해야 하는 문제들은 미리 전처리로 해결할 수도 있다!!
🔥 딕셔너리에서 get할 때 우선 key 있는지부터 if key in my_dict로 점검하거나 my_dict.get(key, default_value) 사용
break: 사용할 때 범위 체크
영향력 주의: 좌표 x, y 위치 바꾸려면 통일성 지켜야 한다.
90도 회전: y=x 대칭이동 + x축 대칭이동
🔥 변수 범위 체크: '크기가 100x100'에 현혹돼서 바로 100이라 선언x!! 각 인자마다 범위 확실히 체크하자.
예외 사항 체크: 예외 사항 찾을 때 너무 작은 값만 신경 쓰는 게 아니라 큰 값도 신경 써라! 양수가 아니라 음수도!
🔥 모든 경우에 대해 삼단논법을 진행해야 한다면, 플로이드 워셜 (삼중 반복문 k,a,b)
아래 메서드는 실수형을 다룸:
```
import math
math.ceil(x)   # 올림
math.floor(x)  # 내림
round(x)       # 반올림
```
코드 재사용: 특정 동작을 반복해야 한다면, 재사용성 고려해서 힘들게 메서드 합치지 말고, 일단 복붙해서 구현하자.
논리 연산자: and에서 왼쪽 피연산자 False일 경우, 자동 False 반환!! (단축 평가)
최장 증가 부분 수열 원리: 각 원소의 지위, 랭크를 매기는 작업을 순차적으로 선행함. 그리고 가장 큰 값이 답.
🔥 반복문 중첩 주의: 반복문 중첩해있을 때, 특정 로직이 어디 안에 있어야 하는지 민감하게 반응하자.
🔥 90도 회전:
```
pythonCopydef rotate_90(arr):
    n = len(arr)
    m = len(arr[0])
    rotated = [[0] * n for _ in range(m)]
    
    for i in range(m):
        for j in range(n):
            rotated[i][j] = arr[n-1-j][i]
            
    return rotated
```
무언가 중요한 기준을 수정했을 때는 그와 관련하여 바꿔야 할 부분이 많다!! 최대한 신경 기울여야 함.
🆘 이런 상황에서 클래스를 선언하는 건 상당히 유용함. 튜플로도 해결가능하긴 함.
🆘 이런 상황이란? 특정 작업이 반복됨에 따라 특정 요소의 고유 정보가 변동될 가능성이 있을 때
🆘 혹은 문자열, 정수와 같이 타입이 다른 데이터를 동시에 저장해야 할 때

---
## MYSQL

WITH A AS ()

🔥 GROUP BY는 GROUP BY에 정의한 내용(컬럼 또는 변형된 컬럼)만 SELECT절에 그대로 사용할 수 있다.

GROUP BY에 정의하지 않은 컬럼을 SELECT절에서 사용하려면 반드시 집계함수 처리를 해야 한다.
SUM() 안에도 WHEN 절, 활용할 수 있다!!

🔥 문제 서술 부분 훑어 읽으며 중요한 부분 있으면 캐치하자!!

🔥 어려운 건 설계가 필요하다! 펜 쓰는 것도 감안해두기

🔥 코드 중복, 코드 재사용성 연연하지 말자. 시간 복잡도가 있는 것도 아니니까. 코드 길어져도 초조해하지 말고 '정확성'에 초점 두자.

🔥 '여성 회원' 이것도 문제의 조건이다!!! 하나하나 꾹꾹 눌러 읽어야 함.

'2022-01-11'로 출력되어야 한다면 DATE-FORMAT!!!

🔥 SQL에서는 순차적 사고보다는 결과적 사고를 하자!!! 순차적 사고를 구현하기는 힘드니까.

열(칼럼) 별칭은 WHERE 절에서 사용 불가능

문자열 합치기 CONCAT(STR1, STR2, ...)

a between b and c: b, c와 일치하는 것도 true. 그러나 아래 주의!

BETWEEN '2012-01-22' AND '2012-01-23' 은
BETWEEN '2012-01-22 00:00:00' AND '2012-01-23 00:00:00' 과 같은거
```
WITH 테이블이름네이밍 AS 
(
    #반복시킬 쿼리
    SELECT 
)
```
🔥 TIMESTAMPDIFF(단위, 날짜1, 날짜2);

SECOND : 초 MINUTE : 분 HOUR : 시 DAY : 일 WEEK : 주 MONTH : 월 QUARTER : 분기 YEAR : 연
LEFT OUTER JOIN

첫 번째 테이블을 기준으로 두 번째 테이블을 조합
첫 번째 테이블은 모두 검색되어야 함.
🔥 오른쪽 = null하면 차집합구할 수 있음.
SET @HOUR = -1;

LIKE

와일드 카드: 여러 파일을 한꺼번에 지정할 목적으로 사용하는 기호
%: 0개 이상의 문자 대신 표현
_: 1개의 문자표현
_012 -> t012, 0012, a012
: %나 _를 포함하려면 \붙이면 됨.
🔥 IF(조건문, 참일 때 값, 거짓일 때 값)

🔥 IFNULL(column_name, '대체할 값')

🔥 문자열 자르기

SUBSTRING(STR, STARTIDX, COUNT) -- MID와 동일 (마지막 파라미터 인덱스가 아니라 개수다!!)
LEFT(STR, COUNT)
RIGHT(STR, COUNT)
🔥 버림: TRUNCATE()

SELECT TRUNCATE(1234.56789 ,1) FROM DUAL; 1234.5
SELECT TRUNCATE(1234.56789 ,4) FROM DUAL; 1234.5678
SELECT TRUNCATE(1234.56789 ,0) FROM DUAL; 1234
SELECT TRUNCATE(1234.56789 ,-1) FROM DUAL; 1230
SELECT TRUNCATE(1234.56789 ,-2) FROM DUAL; 1200
제곱: POW(10, 2); 100

🔥 나머지: MOD(10, 3); 1

🔥 최댓값: GREATEST(3, 2, 1); 3

최솟값: LEAST(3, 2, 1); 1

🔥 LIMIT x, y

x번째항부터 y개 조회
SELECT title, content, writer FROM board LIMIT 3, 5;
3번째 항부터 7번째항까지 조회
🔥 UNION: 중복제외

UNION ALL: 중복 허용

🔥 칼럼 내 값이 중복 있는지 점검하는 습관 좋다!! 중복에 민감해야해!!!!! 문제 처음 읽을 때! 이래서 설명도 읽어야 해

고유 개수 세기에는 DISTINCT가 정말 유용한 듯.

DISTINCT birthcity 이렇게도 사용가능함
🔥 DISTINCT birthyear, birthMonth, birthday: 이건 세 개의 값이 모두 같은 행들만 중복으로 간주함. 1998,09,12 1998,09,12
🔥 특정 요소를 하나라도 뽑지 않아야 한다면 not in 활용

sql 실행순서

FROM, WHERE, GROUP BY, HAVING, SELECT, ORDER BY
🆘🆘 그리고 각 행마다 순차적으로 실행된다!!!!!!
GROUP BY가 SELECT 보다 먼저 실행 되지만, SELECT의 alias를 사용할 수 있다. (DBMS가 알아서 해줌. mysql 기준)

GROUP BY, HAVING, ORDER BY에서 SELECT의 alias를 사용할 수 있다.
서브쿼리를 이용해 쿼리를 이중반복문처럼 구현할 수도 있음.

각 행마다 where에 있는 서브쿼리를 실행함.
서브쿼리에서 메인쿼리 컬럼 사용 가능함.
이를 통해, 특정 조건에 대한 충족을 좀 더 자유롭게 활용할 수 있음..!!
sum이나 count 집계함수 안에 if문을 통해 각 행마다의 값을 지정해줄 수 있다!!!

🆘 이것의 원리 자체가 해당 테이블의 행마다 하나씩 순차적으로 실행되기 때문.

🆘 그렇기에 없는 숫자들을 구현할 때는 그 옆에 있는 열들은 서브쿼리로 처리해야 함.
rank 함수

RANK() OVER ()
DENSE_RANK() OVER () (같은 양이면 순위 똑같게)
🆘 특정 랭킹에 접근하고 싶다면 FROM() 서브쿼리르 사용해야 함!!
SELECT id, amoiunt RANK() OVER (ORDER BY amount desc) AS ranking
FROM emp
🆘 노선별 평균 역 사이 거리 조회하기 <- 여기에서 처럼 concat을 이용한 뒤, 정렬하는 거 조심해야 함!!!
🆘 정렬 조건도 만만히 봐서는 안 된다!!! 정확히 무엇이 기준인지!!! (여기서, 단위는 빼야 함.)
